var documenterSearchIndex = {"docs":
[{"location":"#EDF.jl","page":"API","title":"EDF.jl","text":"","category":"section"},{"location":"","page":"API","title":"API","text":"EDF.jl is a Julia package for working with European Data Format (EDF) and BioSemi Data Format (BDF) files, including reading, writing, and an intermediate representation for direct access to data.","category":"page"},{"location":"#Package-API","page":"API","title":"Package API","text":"","category":"section"},{"location":"#Representation-of-Data","page":"API","title":"Representation of Data","text":"","category":"section"},{"location":"#EDF.File","page":"API","title":"EDF.File","text":"EDF.File{T,I<:IO}\n\nType representing an EDF file with samples encoded as values of type T, which is Int16 for EDF files and Int24 (internally defined) for BDF files.\n\nFields\n\nio::I\nheader::FileHeader\nsignals::Vector{Union{Signal{T},AnnotationsSignal}}\n\n\n\n\n\n","category":"type"},{"location":"#EDF.FileHeader","page":"API","title":"EDF.FileHeader","text":"EDF.FileHeader\n\nType representing the parsed header record of an EDF.File (excluding signal headers).\n\nFields\n\nversion::String: data format version\npatient::Union{String,PatientID}: local patient identification\nrecording::Union{String,RecordingID}: local recording identification\nstart::DateTime: start date/time of the recording\nis_contiguous::Bool: if true, data records are contiguous; is true for non-EDF+-compliant files\nrecord_count::Int: number of data records in the recording\nseconds_per_record::Float64: duration of a data record in seconds\n\n\n\n\n\n","category":"type"},{"location":"#EDF.SignalHeader","page":"API","title":"EDF.SignalHeader","text":"EDF.SignalHeader\n\nType representing the header for a single EDF signal.\n\nFields\n\nlabel::String: the signal's type/sensor label, see https://www.edfplus.info/specs/edftexts.html#label\ntransducer_type::String: non-standardized transducer type information\nphysical_dimension::String: see https://www.edfplus.info/specs/edftexts.html#physidim\nphysical_minimum::Float32: physical minimum value of the signal\nphysical_maximum::Float32: physical maximum value of the signal\ndigital_minimum::Float32: minimum value of the signal that could occur in a data record\ndigital_maximum::Float32: maximum value of the signal that could occur in a data record\nprefilter::String: non-standardized prefiltering information\nsamples_per_record::Int32: number of samples in a data record (NOT overall)\n\n\n\n\n\n","category":"type"},{"location":"#EDF.Signal","page":"API","title":"EDF.Signal","text":"EDF.Signal{T}\n\nType representing a single EDF signal with sample type T.\n\nFields\n\nheader::SignalHeader\nsamples::Vector{T}\n\n\n\n\n\n","category":"type"},{"location":"#EDF.AnnotationsSignal","page":"API","title":"EDF.AnnotationsSignal","text":"EDF.AnnotationsSignal\n\nType representing a single EDF Annotations signal.\n\nFields\n\nsamples_per_record::Int32\nrecords::Vector{Vector{TimestampedAnnotationList}}\n\n\n\n\n\n","category":"type"},{"location":"#EDF.TimestampedAnnotationList","page":"API","title":"EDF.TimestampedAnnotationList","text":"EDF.TimestampedAnnotationList\n\nA type representing a time-stamped annotations list (TAL).\n\nNote that this type's constructor may attempt to round given onset_in_seconds and duration_in_seconds arguments to their nearest representable values in accordance with the EDF+ specification, which a) represents these values as ASCII, b) constrains these values to an 8 character limit, and c) does not allow the use of scientific notation for these fields.\n\nSee EDF+ specification for details.\n\nFields\n\nonset_in_seconds::Float64: onset w.r.t. recording start time (may be negative)\nduration_in_seconds::Union{Float64,Nothing}: duration of this TAL\nannotations::Vector{String}: the annotations associated with this TAL\n\n\n\n\n\n","category":"type"},{"location":"#EDF.PatientID","page":"API","title":"EDF.PatientID","text":"EDF.PatientID\n\nA type representing the local patient identification field of an EDF+ header.\n\nSee EDF+ specification for details.\n\nFields\n\ncode::Union{String,Missing}\nsex::Union{Char,Missing} ('M', 'F', or missing)\nbirthdate::Union{Date,Missing}\nname::Union{String,Missing}\n\n\n\n\n\n","category":"type"},{"location":"#EDF.RecordingID","page":"API","title":"EDF.RecordingID","text":"EDF.RecordingID\n\nA type representing the local recording identification field of an EDF+ header.\n\nSee EDF+ specification for details.\n\nFields\n\nstartdate::Union{Date,Missing}\nadmincode::Union{String,Missing}\ntechnician::Union{String,Missing}\nequipment::Union{String,Missing}\n\n\n\n\n\n","category":"type"},{"location":"#EDF.sample_type","page":"API","title":"EDF.sample_type","text":"EDF.sample_type(file::EDF.File{T})\n\nReturn the encoded type T of the samples stored in file.\n\n\n\n\n\n","category":"function"},{"location":"#EDF.is_bdf","page":"API","title":"EDF.is_bdf","text":"EDF.is_bdf(file)\n\nReturn true if file is a BDF (BioSemi Data Format) file, otherwise false.\n\n\n\n\n\n","category":"function"},{"location":"","page":"API","title":"API","text":"The EDF+ specification introduced the notion of discontiguous signals, denoted with a value of \"EDF+D\" in one of the reserved fields; the EDF.FileHeader type notes this in a Bool field called is_contiguous. EDF.jl always stores signal data contiguously, regardless of whether the data records are declared to be contiguous, but, given an EDF.Signal, users of the package can construct a lazy iterator over non-overlapping chunks of a signal::EDF.Signal via:","category":"page"},{"location":"","page":"API","title":"API","text":"Iterators.partition(signal.samples, signal.header.samples_per_record)","category":"page"},{"location":"#Reading","page":"API","title":"Reading","text":"","category":"section"},{"location":"#EDF.read","page":"API","title":"EDF.read","text":"EDF.read(io::IO)\n\nReturn EDF.read!(EDF.File(io)).\n\nSee also: EDF.File, EDF.read!\n\n\n\n\n\nEDF.read(path)\n\nReturn open(EDF.read, path).\n\n\n\n\n\n","category":"function"},{"location":"#EDF.read!","page":"API","title":"EDF.read!","text":"EDF.read!(file::File)\n\nRead all EDF sample and annotation data from file.io into file.signals and file.annotations, returning file. If eof(file.io), return file unmodified.\n\n\n\n\n\n","category":"function"},{"location":"#EDF.decode","page":"API","title":"EDF.decode","text":"EDF.decode(signal::Signal)\n\nReturn signal.samples decoded into the physical units specified by signal.header.\n\n\n\n\n\n","category":"function"},{"location":"#Writing","page":"API","title":"Writing","text":"","category":"section"},{"location":"#EDF.write","page":"API","title":"EDF.write","text":"EDF.write(io::IO, file::EDF.File)\nEDF.write(path::AbstractString, file::EDF.File)\n\nWrite file to the given output, returning the number of bytes written.\n\n\n\n\n\n","category":"function"}]
}
