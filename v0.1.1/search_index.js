var documenterSearchIndex = {"docs":
[{"location":"#EDF.jl-1","page":"Functionality","title":"EDF.jl","text":"","category":"section"},{"location":"#","page":"Functionality","title":"Functionality","text":"EDF.jl is a Julia package for working with European Data Format (EDF) files, including reading, writing, and an intermediate representation for direct access to data.","category":"page"},{"location":"#Package-API-1","page":"Functionality","title":"Package API","text":"","category":"section"},{"location":"#","page":"Functionality","title":"Functionality","text":"CurrentModule = EDF","category":"page"},{"location":"#Representation-of-Data-1","page":"Functionality","title":"Representation of Data","text":"","category":"section"},{"location":"#","page":"Functionality","title":"Functionality","text":"EDF files consist of a header record, which contains file-level metadata, and a number of contiguous data records, each containing a chunk of each signal. In Julia, we represent this with an EDF.File type that consists of an EDF.Header object and a vector of EDF.Signals.","category":"page"},{"location":"#","page":"Functionality","title":"Functionality","text":"EDF.File\nEDF.Header\nEDF.Signal\nEDF.RecordAnnotation\nEDF.AnnotationsList\nEDF.PatientID\nEDF.RecordingID","category":"page"},{"location":"#EDF.File","page":"Functionality","title":"EDF.File","text":"EDF.File\n\nType representing a parsed EDF file. All data defined in the file is accessible from this type by inspecting its fields and the fields of the types of those fields.\n\nFields\n\nheader (EDF.Header): File-level metadata extracted from the file header\nsignals (Vector{EDF.Signal}): All signals extracted from the data records\nannotations (Vector{EDF.RecordAnnotation} or Nothing): A vector of length header.n_records where each element contains annotations for the corresponding data record, if annotations are present in the file\n\n\n\n\n\n","category":"type"},{"location":"#EDF.Header","page":"Functionality","title":"EDF.Header","text":"EDF.Header\n\nType representing the header record for an EDF file.\n\nFields\n\nversion (String): Version of the data format\npatient (String or EDF.PatientID): Local patient identification\nrecording (String or EDF.RecordingID): Local recording identification\nstart (DateTime): Date and time the recording started\nn_records (Int): Number of data records\nduration (Float64): Duration of a data record in seconds\nn_signals (Int): Number of signals in a data record\nnb_header (Int): Total number of raw bytes in the header record\n\n\n\n\n\n","category":"type"},{"location":"#EDF.Signal","page":"Functionality","title":"EDF.Signal","text":"EDF.Signal\n\nType representing a single signal extracted from an EDF file.\n\nFields\n\nlabel (String): The name of the signal, e.g. F3-M2\ntransducer (String): Transducer type\nphysical_units (String): Units of measure for the signal, e.g. uV\nphysical_min (Float32): The physical minimum value of the signal\nphysical_max (Float32): The physical maximum value of the signal\ndigital_min (Float32): The minimum value of the signal that could occur in a data record\ndigital_max (Float32): The maximum value of the signal that could occur in a data record\nprefilter (String): Description of any prefiltering done to the signal\nn_samples (Int16): The number of samples in a data record (NOT overall)\nsamples (Vector{Int16}): The sample values of the signal\n\n\n\n\n\n","category":"type"},{"location":"#EDF.RecordAnnotation","page":"Functionality","title":"EDF.RecordAnnotation","text":"EDF.RecordAnnotation\n\nType containing all annotations applied to a particular data record.\n\nFields\n\noffset (Float64): Offset from the recording start time (specified in the header) at which the current data record starts\nevent (Vector{String} or Nothing): The event that marks the start of the data record, if applicable\nannotations (Vector{EDF.AnnotationsList}): The time-stamped annotations lists (TALs) in the current data record\nn_bytes (Int): The number of raw bytes per data record in the \"EDF Annotation\" signal\n\n\n\n\n\n","category":"type"},{"location":"#EDF.AnnotationsList","page":"Functionality","title":"EDF.AnnotationsList","text":"EDF.AnnotationsList\n\nType representing a time-stamp annotations list (TAL).\n\nFields\n\noffset (Float64): Offset from the recording start time (specified in the header) at which the event in this TAL starts\nduration (Float64 or Nothing): Duration of the event, if specified\nevent (Vector{String}): List of events for this TAL\n\n\n\n\n\n","category":"type"},{"location":"#EDF.PatientID","page":"Functionality","title":"EDF.PatientID","text":"EDF.PatientID\n\nType representing the local patient identification field of an EDF header, assuming the file is EDF+ compliant. EDF.Files which are parsed from files which are not EDF+ compliant do not contain this type; the corresponding field is instead a String.\n\nFields\n\ncode (String or Missing): The code by which a patient is referred, if known\nsex (Char or Missing): Patient sex, 'M', 'F', or missing if unknown\nbirthdate (Date or Missing): Patient date of birth, if known\nname (String or Missing): Patient name, if known\n\n\n\n\n\n","category":"type"},{"location":"#EDF.RecordingID","page":"Functionality","title":"EDF.RecordingID","text":"EDF.RecordingID\n\nType representing the local recording identification field of an EDF header, assuming the file is EDF+ compliant. EDF.Files which are parsed from files which are not EDF+ compliant do not contain this type; the corresponding field is instead a String.\n\nFields\n\nstartdate (Date or Missing): Start date of the recording\nadmincode (String or Missing): Administration code for the recording\ntechnician (String or Missing): Identifier for the technician or investigator\nequipment (String or Missing): Identifier for the equipment used\n\n\n\n\n\n","category":"type"},{"location":"#","page":"Functionality","title":"Functionality","text":"Per the original EDF specification, the signals are assumed to be continuous across data records. However, the EDF+ specification introduced the notion of discontinuous signals, denoted with a value of \"EDF+D\" in one of the reserved fields. The EDF.Header type notes this in a Bool field called continuous. The signal data is always store contiguously, regardless of whether the data records are declared to be continuous, but, given an EDF.Signal object, users of the package can divide the signal by records if needed using","category":"page"},{"location":"#","page":"Functionality","title":"Functionality","text":"Iterators.partition(signal.samples, signal.n_samples)","category":"page"},{"location":"#","page":"Functionality","title":"Functionality","text":"This will construct a lazy iterator over non-overlapping chunks of the signal, iterating which yields a total of header.n_records items.","category":"page"},{"location":"#Reading-1","page":"Functionality","title":"Reading","text":"","category":"section"},{"location":"#","page":"Functionality","title":"Functionality","text":"EDF.read","category":"page"},{"location":"#EDF.read","page":"Functionality","title":"EDF.read","text":"EDF.read(file::AbstractString)\n\nRead the given file and return an EDF.File object containing the parsed data.\n\n\n\n\n\n","category":"function"},{"location":"#Writing-1","page":"Functionality","title":"Writing","text":"","category":"section"},{"location":"#","page":"Functionality","title":"Functionality","text":"EDF.write","category":"page"},{"location":"#EDF.write","page":"Functionality","title":"EDF.write","text":"EDF.write(io::IO, edf::EDF.File)\nEDF.write(path::AbstractString, edf::EDF.File)\n\nWrite the given EDF.File object to the given stream or file and return the number of bytes written.\n\n\n\n\n\n","category":"function"}]
}
